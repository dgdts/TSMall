layouts:
  - path: cmd/api/main.go
    delims:
      - "{{"
      - "}}"
    body: |-
      package main

      import (
        "context"
        "os"
        "path/filepath"
        "strings"
        "time"

        "{{.GoModule}}/biz/config/global_config"
        "{{.GoModule}}/biz/global_init"
        "{{.GoModule}}/biz/router"
        _ "{{.GoModule}}/kit/xjsoniter"

        protocolconfig "github.com/hertz-contrib/http2/config"
        "github.com/hertz-contrib/http2/factory"

        "github.com/cloudwego/hertz/pkg/app"
        "github.com/cloudwego/hertz/pkg/common/utils"
        "github.com/cloudwego/hertz/pkg/protocol/consts"
      )

      func env() {
        env := strings.ToLower(os.Getenv("ENV"))
        if env == "" {
          env = "dev"
        }
        _ = os.Setenv("ENV", env)
      }

      func main() {
        env()

        workspacePath, err := os.Getwd()
        if err != nil {
          panic(err)
        }
        confPath := filepath.Join(workspacePath, "configs", os.Getenv("ENV"), "conf.yaml")

        // init global config
        global_config.InitGlobalConfig(confPath)

        // init hertz server
        h := global_init.InitServer(global_config.GConfig.Hertz.Service)

        h.AddProtocol("h2", factory.NewServerFactory(
          protocolconfig.WithReadTimeout(time.Minute),
          protocolconfig.WithDisableKeepAlive(false),
        ))

        // add a ping route to test
        h.GET("/ping", func(c context.Context, ctx *app.RequestContext) {
          ctx.JSON(consts.StatusOK, utils.H{
            "ping":   "pong",
            "pod_ip": os.Getenv("POD_IP"),
          })
        })

        // register biz router
        router.GeneratedRegister(h)
        // server start
        h.Spin()
      }

  - path: go.mod
    delims:
      - '{{'
      - '}}'
    body: |-
      module {{.GoModule}}

      go 1.21

      replace (
        github.com/apache/thrift => github.com/apache/thrift v0.13.0
        	ts-gobase v1.0.0 => github.com/dgdts/ts-gobase v0.0.2
        )

  - path: biz/router/register.go
    delims:
      - ""
      - ""
    body: |-
      // Code generated by hertz generator. DO NOT EDIT.

      package router

      import (
      	"github.com/cloudwego/hertz/pkg/app/server"
      )

      // GeneratedRegister registers routers generated by IDL.
      func GeneratedRegister(r *server.Hertz){
      	//INSERT_POINT: DO NOT DELETE THIS LINE!
      }


  - path: configs/dev/conf.yaml
    delims:
      - "{{"
      - "}}"
    body: |-
      global:
        namespace: Development
        env_name: dev
        local_ip: ${POD_IP}
        container_name: ${HOSTNAME}

      mode: local

      hertz:
        app: “YOUR-APP-NAME”
        server: "enterbuild"
        enable_pprof: true
        enable_gzip: true
        enable_access_log: true
        service:
          name: "{{.ServiceName}}"
          addr: ":8888"

      log:
        log_mode: console
        log_level: debug
        log_file_name: "log/hertz.log"
        log_max_size: 10
        log_max_age: 3
        log_max_backups: 50

      registry:
        name: nacos
        namespace: "5b8d6e7c-c562-4001-b1b3-8a9be7cdabec"
        registry_address:
          - 10.11.100.90:8848
        username: "nacos"
        password: "fN2dJoX8LYRbxHJ1yU1x0aQ0vuylViYWuwLUUt"

      selector:
        name: nacos
        namespace: "5b8d6e7c-c562-4001-b1b3-8a9be7cdabec"
        server_addr:
          - 10.11.100.90:8848
        username: "nacos"
        password: "fN2dJoX8LYRbxHJ1yU1x0aQ0vuylViYWuwLUUt"

      config:
        mode: local
        local_config_path: ./configs/dev/biz_config.yaml

        name: nacos
        namespace: "5b8d6e7c-c562-4001-b1b3-8a9be7cdabec"
        server_addr:
          - 10.11.100.90:8848
        username: "nacos"
        password: "fN2dJoX8LYRbxHJ1yU1x0aQ0vuylViYWuwLUUt"

      prometheus:
        enable: true
        addr: ":9099"
        path: "/prometheus/metrics"


  - path: configs/prod/conf.yaml
    delims:
      - "{{"
      - "}}"
    body: |-
      global:
        namespace: Production
        env_name: prod
        local_ip: ${POD_IP}               
        container_name: ${HOSTNAME}       

      mode: nacos

      hertz:
        app: “YOUR-APP-NAME”
        server: "enterbuild"
        enable_pprof: false
        enable_gzip: true
        enable_access_log: true
        service:
          name: "{{.ServiceName}}"
          addr: ":8888"

      log:
        log_mode: console
        log_level: info
        log_file_name: "log/hertz.log"
        log_max_size: 10
        log_max_age: 3
        log_max_backups: 50

      registry:
        name: nacos
        namespace: "5b8d6e7c-c562-4001-b1b3-8a9be7cdabec"
        registry_address:
          - 10.11.100.90:8848
        username: "nacos"
        password: "fN2dJoX8LYRbxHJ1yU1x0aQ0vuylViYWuwLUUt"

      selector:
        name: nacos
        namespace: "5b8d6e7c-c562-4001-b1b3-8a9be7cdabec"
        server_addr:
          - 10.11.100.90:8848
        username: "nacos"
        password: "fN2dJoX8LYRbxHJ1yU1x0aQ0vuylViYWuwLUUt"

      config:
        mode: nacos

        name: nacos
        namespace: "5b8d6e7c-c562-4001-b1b3-8a9be7cdabec"
        server_addr:
          - 10.11.100.90:8848
        username: "nacos"
        password: "fN2dJoX8LYRbxHJ1yU1x0aQ0vuylViYWuwLUUt"

      prometheus:
        enable: true
        addr: ":9099"
        path: "/prometheus/metrics"


  - path: configs/test/conf.yaml
    delims:
      - "{{"
      - "}}"
    body: |-
      global:
        namespace: Test
        env_name: test
        local_ip: ${POD_IP}
        container_name: ${HOSTNAME}   

      mode: nacos

      hertz:
        app: "“YOUR-APP-NAME”"
        server: "enterbuild"
        enable_pprof: false
        enable_gzip: true
        enable_access_log: true
        service:
          name: "{{.ServiceName}}"
          addr: ":8888"

      log:
        log_mode: console
        log_level: debug
        log_file_name: "log/hertz.log"
        log_max_size: 10
        log_max_age: 3
        log_max_backups: 50

      registry:
        name: nacos
        namespace: "5b8d6e7c-c562-4001-b1b3-8a9be7cdabec"
        registry_address:
          - 10.11.100.90:8848
        username: "nacos"
        password: "fN2dJoX8LYRbxHJ1yU1x0aQ0vuylViYWuwLUUt"

      selector:
        name: nacos
        namespace: "5b8d6e7c-c562-4001-b1b3-8a9be7cdabec"
        server_addr:
          - 10.11.100.90:8848
        username: "nacos"
        password: "fN2dJoX8LYRbxHJ1yU1x0aQ0vuylViYWuwLUUt"

      config:
        mode: nacos

        name: nacos
        namespace: "5b8d6e7c-c562-4001-b1b3-8a9be7cdabec"
        server_addr:
          - 10.11.100.90:8848
        username: "nacos"
        password: "fN2dJoX8LYRbxHJ1yU1x0aQ0vuylViYWuwLUUt"

      prometheus:
        enable: true
        addr: ":9099"
        path: "/prometheus/metrics"

  - path: README.md
    delims:
      - ""
      - ""
    body: |-
      # *** Project

      ## introduce

      - Use the [Hertz](https://github.com/cloudwego/hertz/) framework
      - Integration of pprof, cors, recovery, access_log, gzip and other extensions of Hertz.
      - Generating the base code for unit tests.
      - Provides basic profile functions.
      - Provides the most basic MVC code hierarchy.

      ## Directory structure

      |  catalog   | introduce  |
      |  ----  | ----  |
      | conf  | Configuration files |
      | cmd/main.go  | Startup file |
      | hertz_gen  | Hertz generated model |
      | biz/handler  | Used for request processing, validation and return of response. |
      | biz/service  | The actual business logic. |
      | biz/router  | Routing and middleware registration |
      | biz/utils  | Wrapped some common methods |

      ## How to run

      ```shell
      ./build_hz.sh
      ./script/run.sh
      ```

  - path: .hz
    delims:
      - "{{"
      - "}}"
    body: |-
      // Code generated by hz. DO NOT EDIT.

      hz version: {{.hzVersion}},
      handlerDir: biz/handler
      modelDir: hertz_gen
      routerDir: biz/router

  - path: .gitignore
    delims:
      - ""
      - ""
    body: |-
      *.o
      *.a
      *.so
      _obj
      _test
      *.[568vq]
      [568vq].out
      *.cgo1.go
      *.cgo2.c
      _cgo_defun.c
      _cgo_gotypes.go
      _cgo_export.*
      _testmain.go
      *.exe
      *.exe~
      *.test
      *.prof
      *.rar
      *.zip
      *.gz
      *.psd
      *.bmd
      *.cfg
      *.pptx
      *.log
      *nohup.out
      *settings.pyc
      *.sublime-project
      *.sublime-workspace
      !.gitkeep
      .DS_Store
      /.idea
      /.vscode
      /output
      *.local.yml
      /idl/kitex_gen
      /*/kitex_gen
      /hertz_gen/*
      go.sum
      .run

  - path: biz/errno/errno.go
    delims:
      - "{{"
      - "}}"
    body: |-
      package errno

      import (
        "errors"
        "fmt"
      )

      const (
        SuccessCode = 0

        GlobalErrorCode = 1000
      )

      // Global error
      var (
        Success = NewErrNo(SuccessCode, "success")

        UnknownErr   = NewErrNo(GlobalErrorCode+1, "unknown error")
        ParameterErr = NewErrNo(GlobalErrorCode+2, "parameter error")
      )

      type ErrNo struct {
        ErrCode  int32  `json:"err_code"`
        ErrMsg   string `json:"err_msg"`
        ErrCause error  `json:"-"`
      }

      func (e ErrNo) Error() string {
        return fmt.Sprintf("err_code=%d, err_msg=%s", e.ErrCode, e.ErrMsg)
      }

      func NewErrNo(code int32, msg string) ErrNo {
        return ErrNo{code, msg, nil}
      }

      func NewErrCode(code int32) ErrNo {
        return ErrNo{
          ErrCode: code,
          ErrMsg:  "",
        }
      }

      func (e ErrNo) WithMessage(msg string) ErrNo {
        e.ErrMsg = msg
        return e
      }

      func (e ErrNo) WithCause(cause error) ErrNo {
        e.ErrCause = cause
        return e
      }

      func (e ErrNo) Is(target error) bool {
        targetErr, ok := target.(ErrNo)
        if !ok {
          return false
        }
        return e.ErrCode == targetErr.ErrCode
      }

      // ConvertErr convert error to Errno
      func ConvertErr(err error) ErrNo {
        Err := ErrNo{}
        if errors.As(err, &Err) {
          return Err
        }

        s := UnknownErr
        s.ErrMsg = err.Error()
        return s
      }


  - path: build_hz.sh
    delims:
      - "{{"
      - "}}"
    body: |-
      #!/bin/bash
      RUN_NAME="{{.ServiceName}}"
      BASE_DIR=$(pwd)
      OUTPUT=${BASE_DIR}/output
      TARGET_BIN=${OUTPUT}/bin
      TARGET_CONF=${OUTPUT}/configs
      TARGET_DATA=${OUTPUT}/data

      DATE=$(date +"%Y%m%d%H%M%S")

      rm -rf ${OUTPUT}
      mkdir -p ${TARGET_BIN}
      mkdir -p ${TARGET_CONF}
      mkdir -p ${TARGET_DATA}
     
      # 根据当前系统自动切换编译方式
      if [[ `uname` == 'Linux' ]]; then   
          GOOS=linux GOARCH=amd64 go build -o ${TARGET_BIN}/${RUN_NAME} ${BASE_DIR}/cmd/api/main.go
      else
          go build -o ${TARGET_BIN}/${RUN_NAME} ${BASE_DIR}/cmd/api/main.go    
      fi

      cp -rf ${BASE_DIR}/configs/* ${TARGET_CONF}
      echo ${RUN_NAME}" Build Success "${DATE}

  - path: script/run.sh
    delims:
      - "{{"
      - "}}"
    body: |-
      #!/bin/bash
      CURDIR=$(pwd)
      echo "$CURDIR/output/bin/{{.ServiceName}}"
      exec "$CURDIR/output/bin/{{.ServiceName}}"

  - path: script/healthcheck.sh
    delims:
      - "{{"
      - "}}"
    body: |-
      #!/bin/bash
      #!/bin/sh

      # 检查进程是否存活
      #ps -ef | grep "{{.ServiceName}}" | grep -v "grep" | wc -l | awk '{if ($1>0) exit 0; else exit -1;}'

      # 检查端口是否监听
      port_cnt=`netstat -tulpn | grep 'LISTEN' | grep ':8000' | wc -l`
      if [[ $port_cnt -lt 1 ]]; then
          echo "health check fail, no port listen"
          exit 1
      fi

      # 检查进程是否存活
      proc_cnt=`ps aux | grep "{{.ServiceName}}" | grep -v "grep" | wc -l`
      if [[ $proc_cnt -lt 1 ]]; then
          echo "health check fail, no process"
          exit 2
      fi

      exit 0
      
  - path: Makefile
    delims:
      - "{{"
      - "}}"
    body: |-      
      {{.ServiceName}}:
        hz update -idl idl/$(service).proto --customize_package=./template/package.yaml

      all:
      	make {{.ServiceName}}

  - path: Dockerfile
    delims:  
      - "{{"
      - "}}"
    body: |-
      FROM hubzhidc.seasungame.com/tc-devops/ci:golang-1.21.10-jdk-8-centos-7.9 as builder
      LABEL stage=gobuilder

      ENV GOOS linux
      ENV GOARCH amd64
      ENV CGO_ENABLED 0

      ARG ARTIFACT_ID

      WORKDIR /build
      COPY ./$ARTIFACT_ID/output .



      FROM hubzhidc.seasungame.com/tc-devops/os_base:alpine-3.16

      ARG ARTIFACT_ID
      USER root 

      COPY --from=builder /usr/share/zoneinfo /usr/share/zoneinfo
      COPY --from=builder /build /application/$ARTIFACT_ID

      ENV TZ=Asia/Shanghai
      WORKDIR /application/$ARTIFACT_ID

      # COPY /usr/share/zoneinfo /usr/share/zoneinfo
      # COPY ./$ARTIFACT_ID/output .
      EXPOSE 8888
      RUN chmod +x /application/$ARTIFACT_ID/bin/$ARTIFACT_ID && chmod 4755 /bin/busybox && apk update && apk add curl && apk add busybox-extras

      ENTRYPOINT ["./bin/{{.ServiceName}}"]

  - path: biz/global_init/init.go
    delims:
      - "{{"
      - "}}"
    body: |-
      package global_init

      import (
        "fmt"
        "os"
        "os/signal"
        "syscall"

        "{{.GoModule}}/biz/config/biz_config"
        "{{.GoModule}}/biz/config/global_config"
        "{{.GoModule}}/biz/constant"
        "{{.GoModule}}/biz/hertz"
        "{{.GoModule}}/biz/log"
        "{{.GoModule}}/biz/middelware"

        "github.com/cloudwego/hertz/pkg/app/middlewares/server/recovery"
        "github.com/cloudwego/hertz/pkg/app/server/render"
        "github.com/cloudwego/hertz/pkg/common/hlog"
        "github.com/hertz-contrib/cors"
        "github.com/hertz-contrib/gzip"
        "github.com/hertz-contrib/logger/accesslog"
        "github.com/hertz-contrib/pprof"
        jsoniter "github.com/json-iterator/go"

        "github.com/cloudwego/hertz/pkg/app/server"
        "gopkg.in/natefinch/lumberjack.v2"
      )

      func InitServer(service global_config.Service) (h *server.Hertz) {
        // init hlog
        log.InitHLog(&lumberjack.Logger{
          Filename:   global_config.GConfig.Log.LogFileName,
          MaxSize:    global_config.GConfig.Log.LogMaxSize,
          MaxBackups: global_config.GConfig.Log.LogMaxBackups,
          MaxAge:     global_config.GConfig.Log.LogMaxAge,
          Compress:   global_config.GConfig.Log.LogCompress,
        }, log.HLogLevel(global_config.GConfig.Log.LogLevel), global_config.GConfig.Log.LogMode)

        if global_config.GConfig.Mode == global_config.ModeTypeNacos {
          // register to nacos
          h = server.New(hertz.HertzCommonServerSuite{
            Address: global_config.GConfig.Hertz.Service.Address,
            CurrentServiceName: fmt.Sprintf("%s.%s.%s.%s",
              constant.FrameName,
              global_config.GConfig.Hertz.App,
              global_config.GConfig.Hertz.Server,
              global_config.GConfig.Hertz.Service.Name),
            RegistryAddr: global_config.GConfig.Registry.RegistryAddress,
            RegistryType: global_config.GConfig.Registry.Name,
            NamespaceId:  global_config.GConfig.Registry.Namespace,
            Username:     global_config.GConfig.Registry.Username,
            Password:     global_config.GConfig.Registry.Password,
          }.Options()...)
        } else {
          h = server.Default(server.WithHostPorts(global_config.GConfig.Hertz.Service.Address))
        }

        // register middleware
        registerMiddleware(h)

        // init biz config
        biz_config.BizConfigInit(global_config.GConfig.Config)

        h.SetCustomSignalWaiter(func(err chan error) error {
          signalToNotify := []os.Signal{syscall.SIGINT, syscall.SIGHUP, syscall.SIGTERM}
          if signal.Ignored(syscall.SIGHUP) {
            signalToNotify = []os.Signal{syscall.SIGINT, syscall.SIGTERM}
          }
          signals := make(chan os.Signal, 1)
          signal.Notify(signals, signalToNotify...)
          select {
          case sig := <-signals:
            switch sig {
            // case syscall.SIGTERM:
            //     // force exit
            //     return errors.NewPublic(sig.String()) // nolint
            case syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM:
              hlog.SystemLogger().Infof("Received signal: %s\n", sig)
              // graceful shutdown
              return nil
            }
          case err := <-err:
            // error occurs, exit immediately
            return err
          }
          return nil
        })

        // init redis
        // tsredis.InitRedis(nil)

        // init mongodb
        // tsmongodb.InitMongoDB(nil)

        middelware.InitMiddeleware(h)

        return h
      }

      func registerMiddleware(h *server.Hertz) {
        // pprof
        if global_config.GConfig.Hertz.EnablePprof {
          pprof.Register(h)
        }
        // gzip
        if global_config.GConfig.Hertz.EnableGzip {
          h.Use(gzip.Gzip(gzip.DefaultCompression))
        }

        // access log
        if global_config.GConfig.Hertz.EnableAccessLog {
          h.Use(accesslog.New())
        }

        // recovery
        h.Use(recovery.Recovery())

        // cores
        h.Use(cors.Default())

        // customize json marshal ingore omitempty
        render.ResetJSONMarshal(jsoniter.Marshal)
      }

  - path: kit/xjsoniter/jsoniter.go
    delims:
      - ""
      - ""
    body: |-
      package xjsoniter

      import (
        "unsafe"

        "github.com/cloudwego/hertz/pkg/common/hlog"

        jsoniter "github.com/json-iterator/go"
        "github.com/modern-go/reflect2"
      )

      type ignoreOmitEmptyTagExtension struct {
        jsoniter.DummyExtension
      }

      type ignoreOmitEmptyTagEncoder struct {
        originDecoder jsoniter.ValEncoder
      }

      // key logic
      func (p *ignoreOmitEmptyTagEncoder) IsEmpty(ptr unsafe.Pointer) bool {
        return false
      }

      func (p *ignoreOmitEmptyTagEncoder) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
        p.originDecoder.Encode(ptr, stream)
      }

      func (e *ignoreOmitEmptyTagExtension) DecorateEncoder(typ reflect2.Type, encoder jsoniter.ValEncoder) jsoniter.ValEncoder {
        return &ignoreOmitEmptyTagEncoder{encoder}
      }

      func init() {
        hlog.Debugf("fix omitemptytag issue")
        jsoniter.RegisterExtension(&ignoreOmitEmptyTagExtension{})
      }

  - path: biz/bizcontext/bizcontext.go
    delims:
      - ""
      - ""
    body: |-
      package bizcontext

      import "context"

      type User struct {
        UserName string `json:"user_name"`
      }

      type BizContext struct {
        context.Context

        User *User
      }
  - path: biz/config/biz_config/biz_config.go
    delims:
      - "{{"
      - "}}"
    body: |-
      package biz_config

      import (
        "{{.GoModule}}/biz/utils"
        "os"

        "github.com/cloudwego/hertz/pkg/common/hlog"
        "gopkg.in/yaml.v3"

        "{{.GoModule}}/biz/config/global_config"
      )

      var bizConfig *BizConfig

      type BizConfig struct {
        //test_biz_config
        TestBizConfig string `yaml:"test_biz_config"`
      }

      func BizConfigInit(config *global_config.Config) {
        switch config.Mode {
        case global_config.ModeTypeNacos:
          bizConfigNacosInit(config)
        default:
          bizConfigLocalInit(config)
        }
      }

      func bizConfigLocalInit(config *global_config.Config) {
        configBytes, err := os.ReadFile(config.LocalConfigPath)
        if err != nil {
          panic(err)
        }

        var tmpConfig BizConfig
        err = yaml.Unmarshal(configBytes, &tmpConfig)
        if err != nil {
          panic(err)
        }
        setBizConfig(&tmpConfig)
        hlog.Infof("local config: %v", GetBizConfig())
      }

      func bizConfigNacosInit(config *global_config.Config) {
        utils.InitRemoteConfig(*config.RemoteConfig)

        var tmpConfig BizConfig
        err := utils.GetRemoteConfig(config.ConfigDataID, config.ConfigGroup, &tmpConfig)
        if err != nil {
          panic(err)
        }

        setBizConfig(&tmpConfig)
        hlog.Infof("remote config: %v", GetBizConfig())
        // could add watch for hot update, but we should consider the race condition when update config
        // go watch(config.ConfigGroup, config.ConfigDataID)
      }

      func setBizConfig(config *BizConfig) {
        bizConfig = config
      }

      func GetBizConfig() *BizConfig {
        return bizConfig
      }

      func watch(group string, key string) {
        c, err := utils.WatchRemoteConfig(group, key)
        if err != nil {
          hlog.Errorf("watch failed. error: %s", err.Error())
          panic(err)
        }

        for resp := range c {
          tmpConfig := &BizConfig{}
          err := yaml.Unmarshal([]byte(resp), &tmpConfig)
          if err != nil {
            panic(err)
          }
          hlog.Infof("remote config Change tmp: %v", tmpConfig)
          setBizConfig(tmpConfig)
        }
        hlog.Infof("watch config end")
      }
  - path: biz/config/global_config/global_config.go
    delims:
      - ""
      - ""
    body: |-
      package global_config

      import (
        "os"

        "gopkg.in/yaml.v3"
      )

      type Global struct {
        Namespace     string `yaml:"namespace"`
        EnvName       string `yaml:"env_name"`
        LocalIP       string `yaml:"local_ip"`
        ContainerName string `yaml:"container_name"`
      }

      type Hertz struct {
        App             string  `yaml:"app"`
        Server          string  `yaml:"server"`
        BinPath         string  `yaml:"bin_path"`
        ConfPath        string  `yaml:"conf_path"`
        DataPath        string  `yaml:"data_path"`
        EnablePprof     bool    `yaml:"enable_pprof"`
        EnableGzip      bool    `yaml:"enable_gzip"`
        EnableAccessLog bool    `yaml:"enable_access_log"`
        Service         Service `yaml:"service"`
      }

      type Service struct {
        Name    string `yaml:"name"`
        Address string `yaml:"addr"`
      }

      type Log struct {
        LogMode       string   `yaml:"log_mode"`
        LogLevel      string   `yaml:"log_level"`
        LogFileName   string   `yaml:"log_file_name"`
        LogMaxSize    int      `yaml:"log_max_size"`
        LogMaxBackups int      `yaml:"log_max_backups"`
        LogMaxAge     int      `yaml:"log_max_age"`
        LogCompress   bool     `yaml:"log_compress"`
        ExtKeys       []string `yaml:"ext_keys"`
      }

      type Prometheus struct {
        Enable bool   `yaml:"enable"`
        Addr   string `yaml:"addr"`
        Path   string `yaml:"path"`
      }

      type Registry struct {
        Name            string   `yaml:"name"`
        RegistryAddress []string `yaml:"registry_address"`
        Namespace       string   `yaml:"namespace"`
        Username        string   `yaml:"username"`
        Password        string   `yaml:"password"`
      }

      type Selector struct {
        Name       string   `yaml:"name"`
        ServerAddr []string `yaml:"server_addr"`
        Namespace  string   `yaml:"namespace"`
        Username   string   `yaml:"username"`
        Password   string   `yaml:"password"`
      }

      type RemoteConfig struct {
        Name       string   `yaml:"name"`
        ServerAddr []string `yaml:"server_addr"`
        Namespace  string   `yaml:"namespace"`
        Username   string   `yaml:"username"`
        Password   string   `yaml:"password"`
      }

      type ModeType string

      const (
        ModeTypeLocal ModeType = "local"
        ModeTypeNacos ModeType = "nacos"
      )

      // Config is for biz config
      type Config struct {
        Mode ModeType `yaml:"mode"`

        // used when mode is local, path is the config file path
        LocalConfigPath string `yaml:"local_config_path"`

        // used when mode is remote, below is the nacos server config
        RemoteConfig *RemoteConfig `yaml:"remote_config"`
        ConfigGroup  string        `yaml:"config_group"`
        ConfigDataID string        `yaml:"config_data_id"`
      }

      type GlobalConfig struct {
        Env    string
        Global *Global `yaml:"global"`
        Hertz  *Hertz  `yaml:"hertz"`
        Log    *Log    `yaml:"log"`

        Config *Config `yaml:"config"`

        Mode       ModeType    `yaml:"mode"`
        Prometheus *Prometheus `yaml:"prometheus"`
        Registry   *Registry   `yaml:"registry"`
        Selector   *Selector   `yaml:"selector"`
      }

      var (
        GConfig *GlobalConfig
      )

      func InitGlobalConfig(path string) {
        if _, err := os.Stat(path); os.IsNotExist(err) {
          panic(err)
        }

        data, err := os.ReadFile(path)
        if err != nil {
          panic(err)
        }

        var config GlobalConfig
        err = yaml.Unmarshal(data, &config)
        if err != nil {
          panic(err)
        }

        GConfig = &config
      }
  - path: biz/constant/global.go
    delims:
      - ""
      - ""
    body: |-
      package constant

      const (
        FrameName  = "hertz"
        BizContext = "bizcontext"
      )
  - path: biz/constant/http.go
    delims:
      - ""
      - ""
    body: |-
      package constant

      const (
        HeaderAcceptLanguage = "Accept-Language"
      )

  - path: biz/hertz/const.go
    delims:
      - ""
      - ""
    body: |-
      package hertz

      const (
        RegTypeConsul string = "consul"
        RegTypeNacos  string = "nacos"
        RegTypeETCD   string = "etcd"
      )

      const (
        labelMethod     = "method"
        labelStatusCode = "statusCode"
        labelPath       = "path"
        labelBizCode    = "bizStatusCode" // bizStatus

        unknownLabelValue = "unknown"
        succBizStatus     = "0"
      )

      var defaultBuckets = []float64{
        5000,
        10000,
        25000,
        50000,
        100000,
        250000,
        500000,
        1000000,
        2500000,
        5000000,
        10000000,
        25000000,
        50000000,
        100000000,
      }

  - path: biz/hertz/hertz_server_suite.go
    delims:
      - ""
      - ""
    body: |-
      package hertz

      import (
        "os"
        "strconv"
        "strings"

        "github.com/cloudwego/hertz/pkg/app/server"
        "github.com/cloudwego/hertz/pkg/app/server/registry"
        "github.com/cloudwego/hertz/pkg/common/config"
        "github.com/nacos-group/nacos-sdk-go/clients"
        "github.com/nacos-group/nacos-sdk-go/common/constant"
        "github.com/nacos-group/nacos-sdk-go/vo"

        hertz_utils "github.com/cloudwego/hertz/pkg/common/utils"
        consulapi "github.com/hashicorp/consul/api"
        registryconsul "github.com/hertz-contrib/registry/consul"
        registrynacos "github.com/hertz-contrib/registry/nacos"
      )

      type HertzCommonServerSuite struct {
        CurrentServiceName string   `yaml:"current_service_name"`
        RegistryAddr       []string `yaml:"registry_addr"`
        RegistryType       string   `yaml:"registry_type"`
        NamespaceId        string   `yaml:"namespace_id"`
        Username           string   `yaml:"username"`
        Password           string   `yaml:"password"`
        Address            string   `yaml:"address"`

        EnablePrometheusTracer bool   `yaml:"enable_prometheus_tracer"`
        PrometheusTracerAddr   string `yaml:"prometheus_tracer_addr"`
        PrometheusTracerPath   string `yaml:"prometheus_tracer_path"`

        LogLevel string `yaml:"log_level"`
      }

      func (h HertzCommonServerSuite) Options() []config.Option {
        opts := []config.Option{
          server.WithHostPorts(h.Address),
        }

        var r registry.Registry
        switch h.RegistryType {
        case RegTypeConsul:
          r = initHertzConsulReg(&h)
        case RegTypeNacos:
          r = initHertzNacosReg(&h)
        case RegTypeETCD:
          panic("etcd unsupported registry type now")
        default:
          panic("unsupported registry type")
        }

        opts = append(opts, server.WithRegistry(r, &registry.Info{
          ServiceName: h.CurrentServiceName,
          Addr:        hertz_utils.NewNetAddr("tcp", h.Address),
          Weight:      10,
          Tags:        nil,
        }))

        if h.EnablePrometheusTracer {
          opts = append(opts, server.WithTracer(NewPrometheusTracer(
            h.PrometheusTracerAddr,
            h.PrometheusTracerPath,
          )))
        }

        return opts
      }

      // initHertzConsulReg use consul as registry center
      func initHertzConsulReg(h *HertzCommonServerSuite) registry.Registry {
        consulConfig := &consulapi.Config{
          Address: h.RegistryAddr[0],
          Token:   h.Password,
        }
        consulClient, err := consulapi.NewClient(consulConfig)
        if err != nil {
          panic(err)
        }

        r := registryconsul.NewConsulRegister(consulClient, registryconsul.WithCheck(&consulapi.AgentServiceCheck{
          Interval:                       "7s",
          Timeout:                        "5s",
          DeregisterCriticalServiceAfter: "15s",
        }))
        return r
      }

      // initHertzNacosReg 使用nacos作为注册中心
      func initHertzNacosReg(h *HertzCommonServerSuite) registry.Registry {
        sc := make([]constant.ServerConfig, 0)
        for _, addr := range h.RegistryAddr {
          ipAndPort := strings.Split(addr, ":")
          uintPort, err := strconv.Atoi(ipAndPort[1])
          if err != nil {
            panic(err)
          }
          sc = append(sc, constant.ServerConfig{
            IpAddr: ipAndPort[0],
            Port:   uint64(uintPort),
          })
        }
        if h.Username == "" {
          h.Username = os.Getenv("NACOS_USERNAME")
        }
        if h.Password == "" {
          h.Password = os.Getenv("NACOS_PASSWORD")
        }
        cc := constant.ClientConfig{
          NamespaceId:         h.NamespaceId,
          TimeoutMs:           5000,
          NotLoadCacheAtStart: true,
          LogDir:              "/tmp/nacos/log",
          CacheDir:            "/tmp/nacos/cache",
          LogLevel:            h.LogLevel,
          Username:            h.Username,
          Password:            h.Password,
        }

        cli, err := clients.NewNamingClient(
          vo.NacosClientParam{
            ClientConfig:  &cc,
            ServerConfigs: sc,
          },
        )
        if err != nil {
          panic(err)
        }

        return registrynacos.NewNacosRegistry(cli)
      }

  - path: biz/hertz/prometheus_tracer.go
    delims:
      - ""
      - ""
    body: |-
      package hertz

      import (
        "context"
        "net/http"
        "strconv"
        "time"

        "github.com/cloudwego/hertz/pkg/app"
        "github.com/cloudwego/hertz/pkg/common/hlog"
        "github.com/cloudwego/hertz/pkg/common/tracer"
        "github.com/cloudwego/hertz/pkg/common/tracer/stats"
        prom "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/collectors"
        "github.com/prometheus/client_golang/prometheus/promhttp"
      )

      type serverTracer struct {
        serverHandledCounter   *prom.CounterVec
        serverHandledHistogram *prom.HistogramVec
      }

      func (s *serverTracer) Start(ctx context.Context, c *app.RequestContext) context.Context {
        return ctx
      }

      func (s *serverTracer) Finish(ctx context.Context, c *app.RequestContext) {
        if c.GetTraceInfo().Stats().Level() == stats.LevelDisabled {
          return
        }

        httpStart := c.GetTraceInfo().Stats().GetEvent(stats.HTTPStart)
        httpFinish := c.GetTraceInfo().Stats().GetEvent(stats.HTTPFinish)
        if httpFinish == nil || httpStart == nil {
          return
        }
        cost := httpFinish.Time().Sub(httpStart.Time())
        _ = counterAdd(s.serverHandledCounter, 1, genLabels(c))
        _ = histogramObserve(s.serverHandledHistogram, cost, genLabels(c))
      }

      func counterAdd(counterVec *prom.CounterVec, value int, labels prom.Labels) error {
        counter, err := counterVec.GetMetricWith(labels)
        if err != nil {
          return err
        }
        counter.Add(float64(value))
        return nil
      }

      func histogramObserve(histogramVec *prom.HistogramVec, value time.Duration, labels prom.Labels) error {
        histogram, err := histogramVec.GetMetricWith(labels)
        if err != nil {
          return err
        }
        histogram.Observe(float64(value.Microseconds()))
        return nil
      }

      func genLabels(ctx *app.RequestContext) prom.Labels {
        labels := make(prom.Labels)
        labels[labelMethod] = defaultValIfEmpty(string(ctx.Request.Method()), unknownLabelValue)
        labels[labelStatusCode] = defaultValIfEmpty(strconv.Itoa(ctx.Response.Header.StatusCode()), unknownLabelValue)
        labels[labelPath] = defaultValIfEmpty(ctx.FullPath(), unknownLabelValue)
        labels[labelBizCode] = defaultValIfEmpty(ctx.Response.Header.Get(labelBizCode), succBizStatus)

        return labels
      }

      func defaultValIfEmpty(val, def string) string {
        if val == "" {
          return def
        }
        return val
      }

      type prometheusTracerConfig struct {
        buckets            []float64
        enableGoCollector  bool
        registry           *prom.Registry
        runtimeMetricRules []collectors.GoRuntimeMetricsRule
        disableServer      bool
      }

      func defaultConfig() *prometheusTracerConfig {
        return &prometheusTracerConfig{
          buckets:           defaultBuckets,
          enableGoCollector: false,
          registry:          prom.NewRegistry(),
          disableServer:     false,
        }
      }

      func NewPrometheusTracer(addr, path string, options ...PrometheusTracerConfigOption) tracer.Tracer {
        cfg := defaultConfig()

        if len(options) > 0 {
          for _, option := range options {
            option.apply(cfg)
          }
        }

        if !cfg.disableServer {
          http.Handle(path, promhttp.HandlerFor(cfg.registry, promhttp.HandlerOpts{
            ErrorHandling: promhttp.ContinueOnError,
          }))
          go func() {
            if err := http.ListenAndServe(addr, nil); err != nil {
              hlog.Fatal("HERTZ: Unable to start a promhttp server, err: " + err.Error())
            }
          }()
        }

        serverHandledCounter := prom.NewCounterVec(
          prom.CounterOpts{
            Namespace: "hertz_server_throughput",
            Help:      "Total number of HTTPs completed by the server, regardless of success or failure.",
          },
          []string{
            labelMethod,
            labelStatusCode,
            labelPath,
            labelBizCode,
          },
        )
        cfg.registry.MustRegister(serverHandledCounter)

        serverHandledHistogram := prom.NewHistogramVec(
          prom.HistogramOpts{
            Namespace: "hertz_server_latency_us",
            Help:      "Latency (microseconds) of HTTP that had been application-level handled by the server.",
            Buckets:   cfg.buckets,
          },
          []string{
            labelMethod,
            labelStatusCode,
            labelPath,
            labelBizCode,
          },
        )
        cfg.registry.MustRegister(serverHandledHistogram)

        if cfg.enableGoCollector {
          cfg.registry.MustRegister(collectors.NewGoCollector(
            collectors.WithGoCollectorRuntimeMetrics(cfg.runtimeMetricRules...),
          ))
        }

        return &serverTracer{
          serverHandledCounter:   serverHandledCounter,
          serverHandledHistogram: serverHandledHistogram,
        }
      }

      type PrometheusTracerConfigOption interface {
        apply(cfg *prometheusTracerConfig)
      }

      type prometheusTracerConfigOption func(*prometheusTracerConfig)

      func (fn prometheusTracerConfigOption) apply(cfg *prometheusTracerConfig) {
        fn(cfg)
      }

      func WithEnableGoCollector(enable bool) PrometheusTracerConfigOption {
        return prometheusTracerConfigOption(func(cfg *prometheusTracerConfig) {
          cfg.enableGoCollector = enable
        })
      }

      func WithGoCollectorRule(rules ...collectors.GoRuntimeMetricsRule) PrometheusTracerConfigOption {
        return prometheusTracerConfigOption(func(cfg *prometheusTracerConfig) {
          cfg.runtimeMetricRules = rules
        })
      }

      func WithDisableServer(disable bool) PrometheusTracerConfigOption {
        return prometheusTracerConfigOption(func(cfg *prometheusTracerConfig) {
          cfg.disableServer = disable
        })
      }

      func WithHistogramBuckets(buckets []float64) PrometheusTracerConfigOption {
        return prometheusTracerConfigOption(func(cfg *prometheusTracerConfig) {
          cfg.buckets = buckets
        })
      }

      func WithRegistry(reg *prom.Registry) PrometheusTracerConfigOption {
        return prometheusTracerConfigOption(func(cfg *prometheusTracerConfig) {
          cfg.registry = reg
        })
      }

  - path: biz/log/log.go
    delims:
      - ""
      - ""
    body: |-
      package log

      import (
        "io"
        "os"
        "strings"
        "time"

        "github.com/cloudwego/hertz/pkg/common/hlog"
        "github.com/cloudwego/kitex/server"
        hertzzap "github.com/hertz-contrib/logger/zap"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
      )

      const (
        LogModeConsole = "console"
        LogModeFile    = "file"
      )

      func InitHLog(ioWriter io.Writer, level hlog.Level, mode string, extKeys ...string) {
        switch mode {
        case LogModeConsole, "":
          setHConsoleMode(level, extKeys...)
        case LogModeFile:
          setHLogFile(ioWriter, level, extKeys...)
        default:
          hlog.Fatalf("unsupport log mode:[%+v]", mode)
        }
      }

      func setHConsoleMode(level hlog.Level, extKeys ...string) {
        var opts []hertzzap.Option
        hzExterKeys := make([]hertzzap.ExtraKey, 0)
        for _, val := range extKeys {
          hzExterKeys = append(hzExterKeys, hertzzap.ExtraKey(val))
        }
        opts = append(opts,
          hertzzap.WithCoreEnc(
            zapcore.NewJSONEncoder(
              zap.NewDevelopmentEncoderConfig())),
          hertzzap.WithZapOptions(
            zap.AddCaller(),
            zap.AddCallerSkip(3)),
          hertzzap.WithExtraKeys(hzExterKeys),
          hertzzap.WithExtraKeyAsStr())

        logger := hertzzap.NewLogger(opts...)
        fileWriter := io.MultiWriter(os.Stdout)
        logger.SetOutput(fileWriter)
        logger.SetLevel(level)
        hlog.SetLogger(logger)
      }

      func setHLogFile(ioWriter io.Writer, level hlog.Level, extKeys ...string) {
        var opts []hertzzap.Option
        var output zapcore.WriteSyncer
        // non-prod environment will use sync mode for file output
        if !strings.Contains(strings.ToLower(os.Getenv("GO_ENV")), "prod") {
          opts = append(opts, hertzzap.WithCoreEnc(zapcore.NewConsoleEncoder(zap.NewDevelopmentEncoderConfig())))
          output = zapcore.AddSync(ioWriter)
        } else {
          opts = append(opts, hertzzap.WithCoreEnc(zapcore.NewJSONEncoder(zap.NewProductionEncoderConfig())))
          // async log
          output = &zapcore.BufferedWriteSyncer{
            WS:            zapcore.AddSync(ioWriter),
            FlushInterval: time.Minute,
          }
        }
        server.RegisterShutdownHook(func() {
          output.Sync() //nolint:errcheck
        })

        hzExterKeys := make([]hertzzap.ExtraKey, 0)
        for _, val := range extKeys {
          hzExterKeys = append(hzExterKeys, hertzzap.ExtraKey(val))
        }

        opts = append(opts, hertzzap.WithZapOptions(
          zap.AddCaller(),
          zap.AddCallerSkip(3)),
          hertzzap.WithExtraKeys(hzExterKeys),
          hertzzap.WithExtraKeyAsStr())
        logger := hertzzap.NewLogger(opts...)
        logger.SetOutput(output)
        logger.SetLevel(level)
        hlog.SetLogger(logger)
      }

      func HLogLevel(level string) hlog.Level {
        switch level {
        case "trace":
          return hlog.LevelTrace
        case "debug":
          return hlog.LevelDebug
        case "info":
          return hlog.LevelInfo
        case "notice":
          return hlog.LevelNotice
        case "warn":
          return hlog.LevelWarn
        case "error":
          return hlog.LevelError
        case "fatal":
          return hlog.LevelFatal
        default:
          return hlog.LevelInfo
        }
      }

  - path: biz/middelware/auth.go
    delims:
      - ""
      - ""
    body: |-
      package middelware

      import (
        "context"

        "github.com/cloudwego/hertz/pkg/app"
      )

      var _ Middelware = (*auth)(nil)

      type auth struct{}

      func (a *auth) Init() {}

      func (a *auth) GetOrder() int {
        return 1
      }

      func (a *auth) Name() string {
        return "auth"
      }

      var excludePath = map[string]struct{}{
        "/ping": {},
      }

      func (a *auth) Do(ctx context.Context, c *app.RequestContext) {
        // check exclude path
        if _, ok := excludePath[string(c.URI().Path())]; ok {
          return
        }
        // do auth
      }

  - path: biz/middelware/bizcontext.go
    delims:
      - "{{"
      - "}}"
    body: |-
      package middelware

      import (
        "context"

        "{{.GoModule}}/biz/bizcontext"
        "{{.GoModule}}/biz/constant"

        "github.com/cloudwego/hertz/pkg/app"
      )

      var _ Middelware = (*bizContextMiddelware)(nil)

      type bizContextMiddelware struct{}

      func (a *bizContextMiddelware) Init() {}

      func (a *bizContextMiddelware) GetOrder() int {
        return 0
      }

      func (a *bizContextMiddelware) Name() string {
        return "bizcontext"
      }

      func (a *bizContextMiddelware) Do(ctx context.Context, c *app.RequestContext) {
        bizContext := &bizcontext.BizContext{
          Context: ctx,
        }
        c.Set(constant.BizContext, bizContext)
      }

  - path: biz/middelware/init.go
    delims:
      - ""
      - ""
    body: |-
      package middelware

      import (
        "context"
        "sort"

        "github.com/cloudwego/hertz/pkg/app"
        "github.com/cloudwego/hertz/pkg/app/server"
        "github.com/cloudwego/hertz/pkg/common/hlog"
      )

      type Middelware interface {
        Init()
        GetOrder() int
        Do(ctx context.Context, c *app.RequestContext)
        Name() string
      }

      func getRegisterMiddleware() []Middelware {
        ret := []Middelware{
          &bizContextMiddelware{},
          &auth{},
        }

        sort.Slice(ret, func(i, j int) bool {
          return ret[i].GetOrder() < ret[j].GetOrder()
        })

        for _, m := range ret {
          m.Init()
        }

        return ret
      }

      func InitMiddeleware(s *server.Hertz) {
        middleware := getRegisterMiddleware()

        for _, m := range middleware {
          s.Use(m.Do)
          hlog.Infof("load middleware: %s", m.Name())
        }
      }

  - path: biz/response/json.go
    delims:
      - "{{"
      - "}}"
    body: |-
      package response

      import (
        "{{.GoModule}}/biz/bizcontext"
        "{{.GoModule}}/biz/constant"
        "{{.GoModule}}/biz/response/jsonresult"
        "context"
        "errors"
        "net/http"
        "strconv"

        "{{.GoModule}}/biz/errno"

        "github.com/cloudwego/hertz/pkg/app"
      )

      const (
        bizStatusCodeName = "bizStatusCode"
      )

      type JSONHandler[Req any, Res any] func(c *bizcontext.BizContext, req *Req) (*Res, error)

      func JSONErr(c *app.RequestContext, err error) {
        resp := jsonresult.NewJSONErrResult(err)

        c.Set("err", err.Error())
        // bizStatusCode used for prometheus monitor
        c.Response.Header.Set(bizStatusCodeName, strconv.Itoa(int(resp.Code)))
        c.JSON(http.StatusOK, resp)
      }

      func JSON[Req, Res any](ctx context.Context, c *app.RequestContext, handler JSONHandler[Req, Res]) {
        req := new(Req)
        err := c.BindAndValidate(req)
        if err != nil {
          JSONErr(c, errno.ParameterErr)
          return
        }
        rawBizCtx, ok := c.Get(constant.BizContext)
        if !ok {
          JSONErr(c, errors.New("bizcontext not found"))
          return
        }

        bizCtx, ok := rawBizCtx.(*bizcontext.BizContext)
        if !ok {
          JSONErr(c, errors.New("bizcontext type error"))
          return
        }

        resp, err := handler(bizCtx, req)
        if err != nil {
          JSONErr(c, err)
          return
        }
        c.JSON(http.StatusOK, jsonresult.NewJSONSuccessResult(resp))
      }

  - path: biz/response/jsonresult/jsonresult.go
    delims:
      - "{{"
      - "}}"
    body: |-
      package jsonresult

      import (
        "{{.GoModule}}/biz/errno"

        "github.com/cloudwego/hertz/pkg/common/hlog"
      )

      type statusResult struct {
        Code  int32  `json:"code"`
        Msg   string `json:"msg"`
        BzMsg string `json:"bzMsg"`
      }
      type JSONResult struct {
        statusResult
        Data any `json:"data"`
      }

      func NewJSONSuccessResult(data any) *JSONResult {
        return &JSONResult{
          Data: data,
          statusResult: statusResult{
            Code: errno.Success.ErrCode,
            Msg:  errno.Success.ErrMsg,
          },
        }
      }

      func NewJSONErrResult(err error) *JSONResult {
        r := &JSONResult{}
        if err == nil {
          return r
        }
        if e, ok := err.(errno.ErrNo); ok {
          r.Code = e.ErrCode
          r.Msg = e.ErrMsg
          return r
        }
        hlog.Errorf("unexpected err: %+v", err)
        r.Msg = errno.UnknownErr.ErrMsg
        r.Code = errno.UnknownErr.ErrCode
        return r
      }

  - path: biz/utils/remote_config.go
    delims:
      - "{{"
      - "}}"
    body: |-
      package utils

      import (
        "{{.GoModule}}/biz/config/global_config"
        "os"
        "strconv"
        "strings"
        "sync"

        "github.com/nacos-group/nacos-sdk-go/clients"
        "github.com/nacos-group/nacos-sdk-go/clients/config_client"
        "github.com/nacos-group/nacos-sdk-go/common/constant"
        "github.com/nacos-group/nacos-sdk-go/vo"
        "github.com/stretchr/testify/assert/yaml"
      )

      const (
        NacosUsernameEnvKey = "NACOS_USERNAME"
        NacosPasswordEnvKey = "NACOS_PASSWORD"

        NacosClientLogDir   = "/tmp/log"
        NacosClientCacheDir = "/tmp/cache"

        NacosClientTimeoutMs = 5000
      )

      type RemoteConfigManager struct {
        client       config_client.IConfigClient
        serverConfig global_config.RemoteConfig
      }

      var gConfMgr *RemoteConfigManager
      var ones sync.Once

      func InitRemoteConfig(config global_config.RemoteConfig) {
        ones.Do(func() {
          gConfMgr = &RemoteConfigManager{
            serverConfig: config,
          }

          nacosServerConfig := make([]constant.ServerConfig, 0)
          for _, addr := range gConfMgr.serverConfig.ServerAddr {
            ipAndPort := strings.Split(addr, ":")
            uintPort, err := strconv.ParseUint(ipAndPort[1], 10, 64)
            if err != nil {
              panic(err)
            }
            nacosServerConfig = append(nacosServerConfig, constant.ServerConfig{
              IpAddr: ipAndPort[0],
              Port:   uintPort,
            })
          }

          userName := gConfMgr.serverConfig.Username
          if userName == "" {
            userName = os.Getenv(NacosUsernameEnvKey)
          }
          password := gConfMgr.serverConfig.Password
          if password == "" {
            password = os.Getenv(NacosPasswordEnvKey)
          }

          clientConfig := constant.ClientConfig{
            NamespaceId:         gConfMgr.serverConfig.Namespace,
            TimeoutMs:           NacosClientTimeoutMs,
            NotLoadCacheAtStart: true,
            LogDir:              NacosClientLogDir,
            CacheDir:            NacosClientCacheDir,
            Username:            userName,
            Password:            password,
          }

          client, err := clients.CreateConfigClient(map[string]any{
            constant.KEY_SERVER_CONFIGS: nacosServerConfig,
            constant.KEY_CLIENT_CONFIG:  clientConfig,
          })

          if err != nil {
            panic(err)
          }
          gConfMgr.client = client
        })
      }

      func GetRemoteConfig(dataId, group string, out any) error {
        content, err := gConfMgr.client.GetConfig(vo.ConfigParam{
          DataId: dataId,
          Group:  group,
        })

        if err != nil {
          return err
        }

        err = yaml.Unmarshal([]byte(content), out)
        if err != nil {
          return err
        }

        return nil
      }

      func WatchRemoteConfig(dataId, group string) (chan string, error) {
        configChan := make(chan string)
        err := gConfMgr.client.ListenConfig(vo.ConfigParam{
          DataId: dataId,
          Group:  group,
          OnChange: func(namespace, group, dataId, data string) {
            configChan <- data
          },
        })
        return configChan, err
      }

  - path: configs/dev/biz_config.yaml
    delims:
      - ""
      - ""
    body: |-
      test_biz_config: biz_config

  - path: .vscode/launch.json # used for vscode-like editor debug config
    delims:
      - ""
      - ""
    body: |-
      {
          "version": "0.2.0",
          "configurations": [
              {
                  "name": "Launch API",
                  "type": "go",
                  "request": "launch",
                  "mode": "auto",
                  "program": "${workspaceFolder}/cmd/api/main.go",
                  "cwd": "${workspaceFolder}",
                  "env": {
                      "ENV": "dev",
                      "CONF_YAML": "${workspaceFolder}/configs/dev/conf.yaml"
                  }
              }
          ]
      }

